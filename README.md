# data-structure
### 1. 复杂度:衡量程序运行的效率

```json
# 时间复杂度与空间复杂度
# 对资源的消耗:关注时间或空间消耗量与输入数据之间的关系

# 复杂度是一个关于输入数据量n的函数
# 假设代码的复杂度是f(n) -> O(f(n))
# O(n)表示的是,复杂度与计算实例的个数n线性相关
# O(logn) 表示复杂度与计算实例的个数n对数相关

# 复杂度的计算方法遵循以下原则:
	# 复杂度与具体的的常系数无关;如O(n)与O(2n)表示同样的复杂度 O(2n) = O(n+n) = O(n) + O(n)
	# 多项式级的复杂度相加的时候,选择高者作为结果;如O(n*n)+O(n)与 O(n*n)表示同样的复杂度
	
# 经验性结论:
	# 一个顺序结构的代码,时间复杂度是O(1)
	# 二分查找或者更通用的说采用分而治之的二分策略,时间复杂度都是O(logn)	
	# 一个简单的for循环,时间复杂度是O(n)
	# 两个顺序执行的for循环,时间复杂度是O(n) + O(n) = O(2n),也是O(n)
	# 两个嵌套的for循环,时间复杂度是O(n*n)

# 总结:
# 复杂度包括时间复杂度与空间复杂度
# 再具体的计算复杂度时:
	# 它与具体的常系数无关,
	# 复杂度相加的时候,选择高者作为结果,也就是O(n*n)+O(n)与 O(n*n)表示同样的复杂度,
	# O(1)也表示一个特殊的复杂度,即任务与算例个数n无关
# 时间复杂度与代码的结构设计高度相关
# 空间复杂度与代码中数据结构的选择高度相关
```

### 2. 将"昂贵"的时间复杂度换为"廉价"空间复杂度

```json
# 程序开发中降低复杂度的核心方法论:
# 降低复杂度的三个步骤:
	# 暴力算法:在没有任何时间、空间约束下，完成代码任务的开发
	# 无效操作处理：将代码中的无效计算、无效存储剔除，降低时间或空间复杂度（递归、二分法、排序算法、动态规划等常用的算法思维）
	# 时空转换：设计和合理的数据结构，完成时间复杂度与空间复杂度的转移（对数据的操作进行细分，全面掌握常见数据结构的基础知识）
```

### 3. 数据处理的基本操作: 增删查

### 4. 线性表的增删查

```json
# 线性表是n个数据元素的有限序列,常用的是链式表达,通常也叫作线性表或者链表
# 在链表中存储的数据元素叫做结点,一节结点存储的就是一条数据记录
# 每一个结点的结构包括两个部分:
	# 具体的数据
	# 指向下一个结点的指针
# 在链表的最前面,通常会有一个头指针用来指向第一个结点
# 对于链表的最后一个结点,由于在它之后没有下一个节点,因此它的指针是一个空指针

# 链表在新增、删除数据都可以在O（1）的时间复杂度内完成
# 对于查找，不管是按照位置查找还是按照数值条件的查找，都需要对全部数据进行遍历，这就是O（n）的时间复杂度

# 线性表的真正价值在于,他对数据的存储方式是按照顺序的存储
	# 如果数据的元素个数不确定,且需要经常进行数据的新增和删除时,那么链表比较合适;
	# 如果数据元素大小确定,删除插入的操作并不多,那么数组可能更加合适

# 线性链表结构的每个节点,由数据的数值和下一个元素的指针构成
# 根据结构组合方式的不同,除了单向链表以外,还有双向链表,循环链表和双向循环链表等变形
  
```

### 5. 栈的增删查

```json
# 后进先出的线性表

```

### 6. 队列的增删查

```json
# 先进先出

```

### 7. 数组:基于索引的查找

```json

```

### 8. 字符串的匹配

```json

```

### 9. 树和二叉树的增删查

```json

```

### 10. 哈希表

```json

```

### 11. 

```json

```

### 12. 

```json

```

