# data-structure
### 1. 复杂度:衡量程序运行的效率

```json
# 时间复杂度与空间复杂度
# 对资源的消耗:关注时间或空间消耗量与输入数据之间的关系

# 复杂度是一个关于输入数据量n的函数
# 假设代码的复杂度是f(n) -> O(f(n))
# O(n)表示的是,复杂度与计算实例的个数n线性相关
# O(logn) 表示复杂度与计算实例的个数n对数相关

# 复杂度的计算方法遵循以下原则:
	# 复杂度与具体的的常系数无关;如O(n)与O(2n)表示同样的复杂度 O(2n) = O(n+n) = O(n) + O(n)
	# 多项式级的复杂度相加的时候,选择高者作为结果;如O(n*n)+O(n)与 O(n*n)表示同样的复杂度
	
# 经验性结论:
	# 一个顺序结构的代码,时间复杂度是O(1)
	# 二分查找或者更通用的说采用分而治之的二分策略,时间复杂度都是O(logn)	
	# 一个简单的for循环,时间复杂度是O(n)
	# 两个顺序执行的for循环,时间复杂度是O(n) + O(n) = O(2n),也是O(n)
	# 两个嵌套的for循环,时间复杂度是O(n*n)

# 总结:
# 复杂度包括时间复杂度与空间复杂度
# 再具体的计算复杂度时:
	# 它与具体的常系数无关,
	# 复杂度相加的时候,选择高者作为结果,也就是O(n*n)+O(n)与 O(n*n)表示同样的复杂度,
	# O(1)也表示一个特殊的复杂度,即任务与算例个数n无关
# 时间复杂度与代码的结构设计高度相关
# 空间复杂度与代码中数据结构的选择高度相关
```

### 2. 将"昂贵"的时间复杂度换为"廉价"空间复杂度

```json
# 程序开发中降低复杂度的核心方法论:
# 降低复杂度的三个步骤:
	# 暴力算法:在没有任何时间、空间约束下，完成代码任务的开发
	# 无效操作处理：将代码中的无效计算、无效存储剔除，降低时间或空间复杂度（递归、二分法、排序算法、动态规划等常用的算法思维）
	# 时空转换：设计和合理的数据结构，完成时间复杂度与空间复杂度的转移（对数据的操作进行细分，全面掌握常见数据结构的基础知识）
```

### 3. 数据处理的基本操作: 增删查

### 4. 线性表的增删查

```json
# 线性表是n个数据元素的有限序列,常用的是链式表达,通常也叫作线性表或者链表
# 在链表中存储的数据元素叫做结点,一节结点存储的就是一条数据记录
# 每一个结点的结构包括两个部分:
	# 具体的数据
	# 指向下一个结点的指针
# 在链表的最前面,通常会有一个头指针用来指向第一个结点
# 对于链表的最后一个结点,由于在它之后没有下一个节点,因此它的指针是一个空指针

# 链表在新增、删除数据都可以在O（1）的时间复杂度内完成
# 对于查找，不管是按照位置查找还是按照数值条件的查找，都需要对全部数据进行遍历，这就是O（n）的时间复杂度

# 线性表的真正价值在于,他对数据的存储方式是按照顺序的存储
	# 如果数据的元素个数不确定,且需要经常进行数据的新增和删除时,那么链表比较合适;
	# 如果数据元素大小确定,删除插入的操作并不多,那么数组可能更加合适

# 线性链表结构的每个节点,由数据的数值和下一个元素的指针构成
# 根据结构组合方式的不同,除了单向链表以外,还有双向链表,循环链表和双向循环链表等变形
  
```

### 5. 栈的增删查

```json
# 后进先出的线性表  push & pop
# 栈的数据结点必须后进先出
# 后进 --- 栈的数据新增操作只能在末端进行,不允许在栈的中间某个结点后新增数据
# 先出 --- 栈的数据删除操作也只能在末端进行,不允许在栈的某个中间结点后删除数据

# 栈包含表头(栈底)和表尾(用来输入数据,通常叫做栈顶)
# 栈顶和栈底是用来表示这个栈的两个指针
# 栈也有顺序表示和链式表示,分别称作顺序栈和链栈

# 顺序栈:栈的顺序存储可以借助数组来实现
# 把数组的首元素存在栈底,最后一个元素放在栈顶
# 然后定义一个top指针来指示栈顶元素在数组中的位置
# 假设栈中只有一个元素,则top = 0
# 一般以top是否是-1来判定是否是空栈
# 当定义了栈的最大容量为StackSize时,则栈 顶top必须小于StackSize
# 当需要新增数据元素,即入栈操作时,就需要将新插入的元素放在栈顶,并将栈顶指针增加1
# 删除数据元素,即出栈操作,只需要将top-1就可以
# 查找操作,栈没有额外的改变,需要遍历整个栈来完成基于某些条件的数值查找


# 链栈,就是用链表的方式对栈的表示.通常可以把栈顶放在单链表的头部
# 对于链栈,新增数据的压栈操作,与链表的最后插入的新数据基本相同,需要额外处理的,就是栈的top指针
# 在链式栈进行删除操作时,只能在栈顶进行操作,将栈顶的top指针指向栈顶元素的next指针即可完成删除
# 对于链式栈,新增删除元素没有任何循环操作,其时间复杂度均为O(1)
# 对于查找操作,他需要遍历整个栈来完成基于某些条件的数据查找,其时间复杂度是O(n)

# 不管是顺序栈还是链栈,数据的新增,删除,查找与线性表
# 相同点: 操作原理极为相似,时间复杂度完全一样,都雨来当前位置的指针来进行数据对象的操作
# 区别: 新增和删除的对象,只能是栈顶的数据结点

```

### 6. 队列的增删查

```json
# 先进先出
# 先进 --- 队列的数据新增操作只能在末端进行,不允许在队列的中间某个结点后新增数据
# 先出 --- 队列的数据新增操作只能在末端进行,不允许在队列的中间某个结点后删除数据


# 队列存在两种存储方式,顺序队列与链式队列
# 顺序队列 --- 依赖数组实现,其中的数据在内存中也是顺序存储
# 链式队列 --- 依赖链表实现,其中的数据依赖每个结点的指针互联,在内存中并不是顺序存储
# 链式队列,实际上就是只能尾尽头出的线性表的单链表

# 队列对于数据的增删查处理: 队列从队头(front)删除元素,从队尾(rear)插入元素,对于一个顺序队列的数组,设置一个front指针来指向队头,并设置另一个rear指针指向队尾,不断进行插入删除操作时,头尾两个指针都会不断向后移动

# 数组越界问题可以通过队列的一个特殊的变种来解决,叫做循环队列.
# 循环队列进行新增数据元素操作时,首先判断队列是否为满,如果不满,则可以将新元素赋值给队尾,然后让rear指针向后移动一个位置;如果已经排到队列最后一个为位置,则rear指针重新指向头部
# 循环队列的数据操作:循环队列删除操作时,即出队列操作,需要判断队列是否为空,然后将队头元素赋值给返回值,front指针向后移一个位置;如果已经排到最后的位置,就把front指针重新指向到头部

# 链式队列的数据操作:链式队列是一个单链表,同时增加了front指针和rear指针;链式队列通常会增加一个头结点,并另front指针指向头结点,头结点不存储数据,只是用来辅助标识;
# 链式队列进行新增数据操作时,将拥有数据X的新节点s赋值给原队尾结点的后继,即rear.next,然后把当前的s设置为队尾结点,指针rear指向s
# 链式队列进行数据删除操作时,实际删除的是头结点的后继结点;出队列的操作,需要找出头结点的后继,这就是要删除的结点,接着让头结点指向要删除结点的后继,如果这个链表除去头结点外只剩下一个元素,那么删除仅剩下的一个元素后,rear指针就变成野指针了,这时需要让rear指针指向头结点

# 总结:
# 队列继承的线性表的优点与不足,是加了限制的线性表
# 队列的新增和删除操作只能在这个线性表的头和尾进行
# 时间复杂度上:循环队列和链式队列的新增,删除操作都是O(1);在查找操作中,队列只能通过全局遍历的方式进行,需要O(n)的时间复杂度
# 循环队列必须有一个固定的长度,因此存在存储元素数量和空间的浪费问题
# 链式队列更为灵活一些

# 在可以确定队列长度最大值时,建议使用循环队列
# 无法确定队列长度时,应考虑使用链式队列

```

### 7. 数组:基于索引的查找

```json
# 数组在讯处数据时是按照顺序存储的,并且数组在内存中是连续存放的,数据内的数据,可以通过索引直接取出得到
# 数组的所以就是对应数组空间

# 数组新增数据有两种情况:
	# 在数组的最后增加一个新的元素,此时新增一条数据,对原数据产生没有任何影响,可以直接通过新增操作,赋值或者插入一条新的数据即可;时间复杂度是O(1)
	# 如果在数组中间的某个位置新增数据,情况就完全不一样,因为西能了数据之后,会对插入元素位置之后额元素产生影响,具体为这些数据点额位置需要依次向后移动1个位置;世纪少年复杂度是O(n)

# 数组删除数据有两种情况:
	# 在数组的最后删除一个元素,此时删除一条数据后,对元数据没有产生任何影响,可以直接删除改数据,时间复杂度是O(1)
	# 在数组的中间某个位置删除一条数据,同新增操作

# 数据的查找操作: 由于索引的存在,可以索引值,直接在O(1)时间复杂度内查找到某个位置的元素
# 基于数值的查找则需要遍历这个数组,时间复杂度是O(n)

# 数组增删查的时间复杂度:
	# 增加: 若插入数据在后,则时间复杂度为O(1);如果在中间某处插入数据,则时间复杂度为O(n);
	# 删除: 对应位置的删除,扫描全数组,时间复杂度是O(n)
	# 查找: 如果只需根据索引值进行一次查找,时间复杂度是O(1);但是要在数组中查找一个数值满足指定条件的数				据,则时间复杂度是O(n)

# 数组与链表的区别:
	# 1. 链表的长度时可变的,数组的长度时固定的,在申请数组的长度时就已经在内存空间中开辟了若干空间,如果没有引用arrayList时,数组申请的空间永远是在估计了数据的大小后才执行
	# 2. 链表不会根据有序位置存储,进行插入数据元素时,可以使用指针来充分利用内存空间;数组是有序存储的,如果想充分利用内存空间就只能选择顺序存储,而且需要在不取数据,不删数据的情况下才能实现

```

### 8. 字符串的匹配

```json
# 字符串是有n个字符组成的一个有序整体(n>=0)




```

### 9. 树和二叉树的增删查

```json

```

### 10. 哈希表

```json

```

### 11. 

```json

```

### 12. 

```json

```

